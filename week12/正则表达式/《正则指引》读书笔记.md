### 第一部分

#### 第一章 字符组

##### 1.普通字符组
  * [] ：表示在同一位置可能出现的任何字符

##### 2.元字符与转义
  * 元字符：- 表示范围 [ ] ^ $ 都是元字符
  * 转义：在不需要表示特殊意义的时候，只要表示普通字义，这时候就需要用到转义

> 在字符组内部使用- 则需要放在开头 [-0-9]匹配的是 -、0到9
> 如何匹配[012] => \\[012]

##### 3.排除型字符组

  * 表示：[^...]

```
  // 问题场景：匹配一个由两个字符构成的字符串，第一个不是数字，第二个是数字？

  /[^0-9][0-9]/

  // 注：排除型字符组必须匹配一个字符 ***也就是必须占一个位***
  // 比如上面的例子 '8'匹配不到 'A8'可以匹配到
```
> 注意1：在排除型字符组中需要表示横线 - （而不是“-”范围表示法），那么-应该紧跟在^之后，而在普通字符组中，作为普通字符的横线-应该紧跟在开放括号之后

> 注意2：在排除型字符组中，\^是一个元字符组，但是只有它紧跟在[之后才是一个元字符，如果想要表示^字符（不是元字符），只需要不紧挨着[即可

##### 4.字符组简记法

* 对于[0-9]、[a-z]等常用字符组，正则表达式提供了字符组简记法

* 常见的字符组简记法有 \d \w \s
  * \d === [0-9]
  * \w === [0-9a-zA-Z_]
  * \s === [ \t\r\n\v\f]

> \t:  水平制表符。将当前位置移到下一个tab位置
  \r:  回车。将当前位置移到本行的开头
  \n:  回车换行。将当前位置移到下一行的开头  
  \v:  垂直制表
  \f:  换页。将当前位置移到下一页的开头 

* 排除字符组简记法
  * \D \W \S

* 妥善利用互补属性 ***可以匹配任意字符***
  * [\s\S]
  * [\w\W]
  * [\d\D]
  

#### 第二章 量词

##### 1.一般形式

  * {m,n} m是下限，n是上限
> {n} 之前的元素必须出现n次
  {m,n} 之前的元素最少出现m次，最多出现n次
  {m,} 之前的元素最少出现m次，出现次数无上限
  {0,n} 之前的元素可以不出现，也可以出现，最多出现n次

##### 2.常用量词

  * {m,n}是通用形式的量词，正则表达式还有三个常用量词， + ? * 可以理解为量词简记法

> \* 等价于 {0,} 可能出现，也可能不出现，出现次数没有上限   
> \+ 等价于 {1,} 至少出现一次，出现次数没有上限  
> ? 等价于 {0,1} 至多出现1次，也可能不出现

* 例子：HTML标签的匹配

```
// open tag匹配
reg = /^<[^/][^>]*>$/;
// close tag
reg = /^</[^>]+>$/;
// self-closing tag
reg = /^<[^>]+/>$/;
```

##### 3.数据提取

* 调用函数返回匹配的内容

##### 4.点号

* . 可以匹配任意字符，只有换行符\n不能匹配

* 如果非要匹配换行符，可以使用[\s\S]

##### 5.匹配优先量词和忽略优先量词
* 匹配优先量词：.* 会首先把符合条件的字符串全都匹配一遍，再根据后面的规则进行回溯
  * 以匹配"qutoed string" and another"为例，会匹配到错误的结果
  ![a5e65d2de1467ddab1c5295b96010ab.png](https://upload-images.jianshu.io/upload_images/19689657-5738c72acf76dac9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
* 忽略优先量词：*? 如果不确定是否要匹配，忽略优先量词会选择“不匹配”的状态，会尝试表达式之后的元素，如果尝试失败，再回溯，选择之前保存的“匹配”状态。

> 二者唯一的区别是：忽略优先量词会优先选择“忽略”，而匹配优先量词会优先选择“匹配”

![66cc6c9ba767e9bb3b8a1465e2f3da3.png](https://upload-images.jianshu.io/upload_images/19689657-c3bc55a499433930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
##### 6.转义
* \  将元字符转义为字符

![c2767d7979d3bb050e389be35f889b7.png](https://upload-images.jianshu.io/upload_images/19689657-6bd8079866b2d83a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
![e7a084ec59a0ee117f0e2b00a683b5b.png](https://upload-images.jianshu.io/upload_images/19689657-940b30cf5c8b3331.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


#### 第三章 括号

##### 1.分组
* 由一个问题引入：
> 如何匹配身份证号码？  
> 1.身份证号码分为15位和18位
> 2.首位是数字，但不能为0   =>[1-9]
> 3.除去首末2位，剩下13位或16位，且都是数字 =>\d{13,16}
> 4.末尾可能是数字，也可能是x => [0-9x]
> 15位身份证号码匹配规则 => [1-9]\d{14}
> 18位身份证号码匹配规则 => [1-9]\d{14}\d{2}{0-9x}
> 所以，以15位号码的匹配为基础，末尾加上可能出现的\d{2}[0-9x]即可
> 最终这个正则表达式是这样的： [1-9]\d{14}(\d{2}{0-9x})?
***上面括号的这种功能叫做分组***

##### 2.多选结构
* 多选结构的形式(...|...)，在括号类以竖线|分隔开多个子表达式，这些子表达式也叫作多选分支
> 还是以身份证号的匹配为例
> 多选结构两边最好加上括号()
([1-9]\d{14}|[1-9]\d{14}\d{2}[0-9x])

##### 3.引用分组（捕获分组）
![如图，捕获分组](https://upload-images.jianshu.io/upload_images/19689657-4dbc7f77ae618af1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* 3.1反向引用
  * 含义：在正则表达式内部引用之前的捕获分组匹配的文本（也就是左侧），其形式也是\num, 其中num是引用分组的编号。
  * 举个例子
  > 匹配一个单词中是否有重叠的单词，用/[a-z][a-z]/显然不行，因为前后两个单词没有任何关联，所以就必须用/([a-z])\1/,这样就可以在正则表达式内部捕获分组。
  ***反向引用的是由之前表达式决定的具体文本，而不是符合某种规则的未知文本***
  ***也就是说反向引用的时候，会引用到和前面子表达式一模一样的表达式，像单词的重叠等等***

* 3.2各种引用的记法
  > 对分组的引用可能出现在三种场合：
  1.匹配完成之后，用group之类的方法提取数据
  2.在进行正则表达式替换时，用\num引用
  3.在正则表达式内部，用\num引用

* 3.3命名分组：将分组的数字编号标识换成自定义命名方法

  ```
  let hd = \`
  <h1>houdunren</h1>
  <span>后盾人</span>
  <h2>hdcms</h2>
  \`;
  let reg = /<(?<tag>h[1-6])>(?<con>[\s\S]*)<\/\1>/gi;
  console.log(hd.replace(reg, \`<p>$<con></p>\`));
  ```
* 3.4 (...|...)的转义
  * 以/(a|b)/为例  => /\(a\|b\)/


#### 第四章 断言

> 正则表达式中大多数结构匹配的文本会出现在最终的匹配结果中，但是有些结构并不真正匹配文本，而只负责判断在某个位置左/右侧的文本是否符合要求，这种结构被称为断言。常见的断言有三类：单词边界、行起始/结束位置、环视。

##### 1.单词边界

* \b  => \brow\b

![如图，单词边界](https://upload-images.jianshu.io/upload_images/19689657-67dd6871b4d7981d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

##### 2.行起始/结束位置

> 单词边界匹配的是某个位置而不是文本，在正则表达式中，这类匹配的位置的元素叫做锚点，它用来定位到某个位置。常用的锚点还有^和$。
> 补充一个小知识点：敲回车键就等于输入行终止符，结束当前行，新起一行。 \r字符代表“回车符” \n代表“换行符”。

![如图，不同平台下的行终止符](https://upload-images.jianshu.io/upload_images/19689657-f993266ac3723d7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* ^ 会匹配到每个行终止符之后的位置

![5f0712198f89472300369076fe583c5.png](https://upload-images.jianshu.io/upload_images/19689657-2501f72c46eb7fe6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

* $ 会匹配到每个行终止符之前的位置

![2afc7192a62868e28e26febe6d4f28c.png](https://upload-images.jianshu.io/upload_images/19689657-183c2a6cbe45716a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


##### 3.环视

  * 肯定顺序环视 (?=...) 举例：A(?=B)  只匹配后面紧跟B的A
  * 否定顺序环视 (?!...) 举例：A(?!B)  只匹配后面没有B的A
  * 肯定逆序环视 (?<=...) 举例：(?<=B)A  只匹配前面紧跟B的A
  * 否定逆序环视 (?<!...) 举例：(?<!B)A  只匹配前面没有B的A

  ***例子***
  ```
  // 1.吃掉空格
  // 去掉多余的空白字符
	let reg = /(?<![a-zA-Z])\s+(?![a-zA-Z])/g;
	let str = '中   英  文   混排，some english word，有   多   余的空 白 字符';
	console.log(str.replace(reg, ''))


  // 2.数字加,号
  let reg = /(?<=\d)(?=(\d{3})+(?!\d))/g;
  ```

#### 第四章 匹配模式

##### 1.不区分大小写

* let reg = /regex/i;

##### 2.多行模式

* let reg = /regex/m;

##### 3.注释模式
* let reg = /regex/x;